<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Architecture (read-dwarf.Architecture)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="index.html">Up</a> â€“ <a href="index.html">read-dwarf</a> &#x00BB; Architecture</nav><h1 id="architecture"><a href="#architecture" class="anchor"></a>Architecture</h1><p>Here I will present how to describe a symbolic state of a specific architecture in read-dwarf.</p><p>The architectures are listed by the <a href="Config__/Arch/index.html#type-t"><code>Config.Arch.t</code></a> enumeration. Not all architectures in the enumeration have the full support, but an architecture must be in the enumeration to be supported. Feel free to add others. This enumeration is used everywhere to refer to various architectures.</p><nav class="toc"><ul><li><a href="#architecture-as-a-virtual-module">Architecture as a Virtual Module</a></li><li><a href="#architectural-features">Architectural features</a></li><li><a href="#representation-of-the-architectural-state">Representation of the architectural state</a></li></ul></nav></header><h2 id="architecture-as-a-virtual-module"><a href="#architecture-as-a-virtual-module" class="anchor"></a>Architecture as a Virtual Module</h2><p>read-dwarf uses <a href="https://dune.readthedocs.io/en/stable/variants.html">Dune's virtual modules</a> to parameterise on the architecture, though currently there is only one supported: <code>aarch64</code>. Any executable (including inline test executables) must therefore be given valid implementation of the virtual module.</p><p>The signature for the architecture is in <a href="Sig/index.html"><code>Sig</code></a>, the only module in a Dune library called <code>sig</code>; an implementation is in <code>src/arch/aarch64/sig.ml</code>, as part of a library called <code>sig_aarch64</code>. Because <a href="Arch/index.html"><code>Arch</code></a> relies on <a href="Sig/index.html"><code>Sig</code></a>, it too becomes virtual, and so does every module that uses <a href="Arch/index.html"><code>Arch</code></a>. See <code>src/isla/dune</code> to see how to integrate this for running inline tests, otherwise simply add <code>sig_aarch64</code> (or any other implementation module) to the <code>libraries</code> Dune stanza when defining an executable (see <code>src/bin/dune</code> and <code>src/tests/dune</code> for examples).</p><h2 id="architectural-features"><a href="#architectural-features" class="anchor"></a>Architectural features</h2><p>A lot of architecture specific things, like the function call ABI, the physical memory size and some other things are in the <a href="Arch/index.html"><code>Arch</code></a> module. However some things are not. For example the list of registers and their SMT types (<a href="Ast/index.html#type-ty"><code>Ast.ty</code></a>) are managed by the <a href="State/Reg/index.html"><code>State.Reg</code></a> module. This is because the register list is not statically hard-coded. It is deduced at run-time from isla, which means that we do not need to maintain a list of system register anywhere. Obviously the <a href="Arch/index.html"><code>Arch</code></a> module need to know about some register to manage the ABI, so those registers will be introduced by <a href="Arch/index.html"><code>Arch</code></a>, but all the other register are only introduced if an instruction touching them is used. This means that if a system register is never used, it's exactly the same as if doesn't exist for read-dwarf.</p><h2 id="representation-of-the-architectural-state"><a href="#representation-of-the-architectural-state" class="anchor"></a>Representation of the architectural state</h2><p>Full architectural state are represented by value of type <a href="State/index.html#type-t"><code>State.t</code></a>, those value are symbolic and actually represent set of concrete state. This is explained in <a href="State/index.html"><code>State</code></a> it self.</p><p>All state are derived from other state using <a href="State/index.html#val-copy"><code>State.copy</code></a>, apart from the first one which should be <a href="Run/Init/index.html#val-state"><code>Run.Init.state</code></a>. When calling that function, Isla will be called on a dummy instruction to get the isla initialization sequence. Currently the <a href="Run/Init/index.html"><code>Run.Init</code></a> module just considers the Isla start state as the initial state. To get the initial state at function entry, only must get the ABI of the function (of type <a href="Arch/index.html#type-func_abi"><code>Arch.func_abi</code></a>) and then call <a href="Arch/index.html#type-func_abi.init"><code>Arch.func_abi.init</code></a></p></div></body></html>