<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>InstructionPipeline (read-dwarf.InstructionPipeline)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="index.html">Up</a> â€“ <a href="index.html">read-dwarf</a> &#x00BB; InstructionPipeline</nav><h1 id="instruction-pipeline"><a href="#instruction-pipeline" class="anchor"></a>Instruction Pipeline</h1><p>This page describe the whole instruction pipeline from how isla is called, to how to run them on <a href="State/index.html"><span>states</span></a>.</p><p>The main idea to represent instruction semantics, is that of trace. A trace is a list of event that affect the current machine state. Those trace may also contain assertions, which means that the trace only decribes the behavior of a state that satisfy those assertions, and do not define any behavior for a state that do not satisfy those assertion. With a set of such traces you can define the behavior of a whole instruction.</p><p>If a state statisfy none of the assertion of any traces of an instruction then running that instruction on that state is undefined behavior. In pratice even if the normal model of sail fully defines an instruction on every state, we will manually make some behavior undefined. In particular all processors exceptions are considered undefined behavior for now.</p><p>In the implementation there is two different fromat for traces: The original isla format from the isla tool and a custom simpler format in the <a href="Trace/index.html"><code>Trace</code></a> module.</p><nav class="toc"><ul><li><a href="#isla">Isla</a><ul><li><a href="#calling-isla">Calling isla</a></li><li><a href="#preprocessing-of-isla-traces">Preprocessing of isla traces</a></li><li><a href="#isla-traces-caching">Isla traces caching</a></li><li><a href="#typing-and-register-learning">Typing and register learning</a></li><li><a href="#running-isla-traces-directly">Running Isla traces directly</a></li></ul></li><li><a href="#trace-and-instr">Trace and Instr</a></li></ul></nav></header><h2 id="isla"><a href="#isla" class="anchor"></a>Isla</h2><p><a href="https://github.com/rems-project/isla">Isla</a> is a tool to symbolically execute a Sail ISA semantic description. Isla will take such semantics and use it to generate symbolic traces for instructions, In this section I describe how I process those traces. The interesting types are defined in <a href="Isla/index.html"><code>Isla</code></a>.</p><h3 id="calling-isla"><a href="#calling-isla" class="anchor"></a>Calling isla</h3><p>First to call isla itself. All of this is done in <a href="Isla/Server/index.html"><code>Isla.Server</code></a>. The Isla tool suite expect <code>*.ir</code> file that is some sort of preprocessed sail source.</p><p>This processing is done by <code>isla-sail</code>, but they can be found in <a href="https://github.com/rems-project/isla-snapshots"><code>isla-snapshots</code></a>. For now we also keep a working snapshot <code>aarch64.ir</code> in the root directory.</p><p>To call isla, <a href="Isla/Server/index.html"><code>Isla.Server</code></a> use the <code>isla-client</code> program. This program will take an hexadecimal opcode and call the <code>isla_client</code> sail function in the <code>*.ir</code> file. This function take the opcode, decode it and run it, all of which is done symbolically by isla. <code>isla-client</code> then send back a symbolic recording of all operations used by the sail code. This code is parsed using the <code>isla-lang</code> library by the <a href="Isla/index.html"><code>Isla</code></a> module that is a wrapper around <code>isla-lang</code> functionality.</p><h3 id="preprocessing-of-isla-traces"><a href="#preprocessing-of-isla-traces" class="anchor"></a>Preprocessing of isla traces</h3><p>As the raw trace contained by isla are big and contain a lot of useless information, I first preprocess them to remove a maximum of useless part in <a href="Isla/Preprocess/index.html"><code>Isla.Preprocess</code></a></p><h3 id="isla-traces-caching"><a href="#isla-traces-caching" class="anchor"></a>Isla traces caching</h3><p>Isla trace are <a href="Utils/Cache/index.html"><span>cached</span></a> by <a href="Isla/Cache/index.html"><code>Isla.Cache</code></a> by opcode. This organisation assumes that there is no configuration to send to isla before symbolically running an instruction and thus each opcode correspond to a single trace representation.</p><h3 id="typing-and-register-learning"><a href="#typing-and-register-learning" class="anchor"></a>Typing and register learning</h3><p>Then <a href="Isla/Type/index.html"><code>Isla.Type</code></a> can be used to type the isla traces and at the same time discover all register used by the trace and thus potentially add them to the <a href="State/Reg/index.html"><code>State.Reg</code></a> module.</p><h3 id="running-isla-traces-directly"><a href="#running-isla-traces-directly" class="anchor"></a>Running Isla traces directly</h3><p>There are two way of used those isla traces, running them directly on states with <a href="Isla/Run/index.html"><code>Isla.Run</code></a> which is kind of deprecated, or going trough the internal <a href="Trace/index.html"><code>Trace</code></a> format.</p><h2 id="trace-and-instr"><a href="#trace-and-instr" class="anchor"></a>Trace and Instr</h2><p>Even after preprocession, Isla traces are still quite complex. They consider meaningful event that in the usual setting are not like reading a register. They also contain a lot a possible event about processor sleeping and concurency that read-dwarf do not support. Therefore a new trace format has been created in <a href="Trace/index.html"><code>Trace</code></a> that only contains the part of behavior that read-dwarf actually use and understand. The trace are also cached in <a href="Trace/Cache/index.html"><code>Trace.Cache</code></a>.</p><p>Full instruction are represented by <span class="xref-unresolved" title="unresolved reference to &quot;Run.Instr.t&quot;"><a href="Run/index.html#module-Instr"><code>Run.Instr</code></a>.t</span> that contain all the traces but also additional metadata that can be useful.</p><p>See <a href="SymbolicExecution.html"><code>SymbolicExecution</code></a> to see how to run those traces.</p></div></body></html>