<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Base (read-dwarf.State__.Base)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">read-dwarf</a> &#x00BB; <a href="../index.html">State__</a> &#x00BB; Base</nav><h1>Module <code>State__.Base</code></h1><nav class="toc"><ul><li><a href="#state-id">State id</a></li><li><a href="#state-variable-management">State variable management</a></li><li><a href="#state-expression-and-typed-value-management">State expression and typed-value management</a></li><li><a href="#state-memory-management">State memory management</a></li><li><a href="#state-type">State type</a></li><li><a href="#stateid">State to id management</a></li><li><a href="#state-management">State management</a></li><li><a href="#state-convenience-manipulation">State convenience manipulation</a></li><li><a href="#state-memory-accessors">State memory accessors</a></li><li><a href="#state-register-accessors">State register accessors</a></li><li><a href="#pc-manipulation">Pc manipulation</a></li><li><a href="#pretty-printing">Pretty printing</a></li></ul></nav></header><aside><p>This module introduce a type to represent the state of the machine.</p><p>The symbolic state in this module do not mathematically represent a single state but a set of concrete state with all the symbolic variable over the whole range of their types. State also contain assertions, and so only represent the subset of concrete states, that satisfy all assertions.</p><p>Currently the state type only represent the register (including system register) and sequential memory part of an actual machine state. Any other architectural state is not represented.</p><p>Additionally, state contain C type information for the <a href="../../Ctype/index.html"><code>Ctype</code></a> inference system. Those fields are not semantically part of the state and do not influence in any way which concrete states are represented by the symbolic state. Expect for provenance information: Pointers can be tagged with provenance information which mean that they are part of a specific restricted block of memory or the main block. See <a href="Mem/index.html"><code>Mem</code></a> for more information. Thus all the implicit non-aliasing assertion implied by those provenance field are to be considered as part of the group of assertion restricting the set of concrete state represented by a symbolic state.</p><p>The presence of C types is optional, which means that this state type can be used in a completely untyped context.</p><p>Concrete detail about how symbolic state are represented in Ocaml is in the documentation of <a href="index.html#type-t"><code>t</code></a>.</p></aside><section><header><h2 id="state-id"><a href="#state-id" class="anchor"></a>State id</h2></header><dl><dt class="spec module" id="module-Id"><a href="#module-Id" class="anchor"></a><code><span class="keyword">module</span> <a href="Id/index.html">Id</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The type of a state ID. for now it's an integer, but it may change later In particular whether a state belong to O0 or O2 may be part of the <code>id</code> at some point.</p></dd></dl><dl><dt class="spec type" id="type-id"><a href="#type-id" class="anchor"></a><code><span class="keyword">type</span> id</code><code> = <a href="Id/index.html#type-t">Id.t</a></code></dt></dl></section><section><header><h2 id="state-variable-management"><a href="#state-variable-management" class="anchor"></a>State variable management</h2></header><dl><dt class="spec module" id="module-Var"><a href="#module-Var" class="anchor"></a><code><span class="keyword">module</span> <a href="Var/index.html">Var</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This module provide state variables. Those are all symbolic variables that may appear in a state. If the same (in the <a href="Var/index.html#val-equal"><code>Var.equal</code></a> sense) variable appear in two state, that mean that when considered together, there is an implicit relation between them.</p></dd></dl><dl><dt class="spec type" id="type-var"><a href="#type-var" class="anchor"></a><code><span class="keyword">type</span> var</code><code> = <a href="Var/index.html#type-t">Var.t</a></code></dt><dd><p>The type of variables</p></dd></dl></section><section><header><h2 id="state-expression-and-typed-value-management"><a href="#state-expression-and-typed-value-management" class="anchor"></a>State expression and typed-value management</h2></header><dl><dt class="spec module" id="module-Exp"><a href="#module-Exp" class="anchor"></a><code><span class="keyword">module</span> <a href="Exp/index.html">Exp</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module for state expressions</p></dd></dl><dl><dt class="spec type" id="type-exp"><a href="#type-exp" class="anchor"></a><code><span class="keyword">type</span> exp</code><code> = <a href="Exp/index.html#type-t">Exp.t</a></code></dt></dl><dl><dt class="spec module" id="module-Tval"><a href="#module-Tval" class="anchor"></a><code><span class="keyword">module</span> <a href="Tval/index.html">Tval</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module for optionally typed state expressions. Those are symbolic values which may or may not have a C type.</p></dd></dl><dl><dt class="spec type" id="type-tval"><a href="#type-tval" class="anchor"></a><code><span class="keyword">type</span> tval</code><code> = <a href="Tval/index.html#type-t">Tval.t</a></code></dt></dl></section><section><header><h2 id="state-memory-management"><a href="#state-memory-management" class="anchor"></a>State memory management</h2></header><dl><dt class="spec module" id="module-Mem"><a href="#module-Mem" class="anchor"></a><code><span class="keyword">module</span> <a href="Mem/index.html">Mem</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This module manages the memory part of the state.</p></dd></dl></section><section><header><h2 id="state-type"><a href="#state-type" class="anchor"></a>State type</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span class="keyword">private</span> </code><code>{</code><table class="record"><tr id="type-t.id" class="anchored"><td class="def field"><a href="#type-t.id" class="anchor"></a><code>id : <a href="index.html#type-id">id</a>;</code></td></tr><tr id="type-t.base_state" class="anchored"><td class="def field"><a href="#type-t.base_state" class="anchor"></a><code>base_state : <span><a href="index.html#type-t">t</a> option</span>;</code></td><td class="doc"><p>The immediate dominator state in the control flow graph</p></td></tr><tr id="type-t.locked" class="anchored"><td class="def field"><a href="#type-t.locked" class="anchor"></a><code><span class="keyword">mutable</span> locked : bool;</code></td><td class="doc"><p>Tells if the state is locked</p></td></tr><tr id="type-t.regs" class="anchored"><td class="def field"><a href="#type-t.regs" class="anchor"></a><code><span class="keyword">mutable</span> regs : <span><a href="Tval/index.html#type-t">Tval.t</a> <a href="../../State/Reg/Map/index.html#type-t">State.Reg.Map.t</a></span>;</code></td><td class="doc"><p>The values and types of registers</p></td></tr><tr id="type-t.read_vars" class="anchored"><td class="def field"><a href="#type-t.read_vars" class="anchor"></a><code>read_vars : <span><a href="Tval/index.html#type-t">Tval.t</a> <a href="../../Utils/Vec/index.html#type-t">Utils.Vec.t</a></span>;</code></td><td class="doc"><p>The results of reads made since base state</p></td></tr><tr id="type-t.asserts" class="anchored"><td class="def field"><a href="#type-t.asserts" class="anchor"></a><code><span class="keyword">mutable</span> asserts : <span><a href="index.html#type-exp">exp</a> list</span>;</code></td><td class="doc"><p>Only asserts since base_state</p></td></tr><tr id="type-t.mem" class="anchored"><td class="def field"><a href="#type-t.mem" class="anchor"></a><code>mem : <a href="Mem/index.html#type-t">Mem.t</a>;</code></td></tr><tr id="type-t.elf" class="anchored"><td class="def field"><a href="#type-t.elf" class="anchor"></a><code>elf : <span><a href="../../Elf/File/index.html#type-t">Elf.File.t</a> option</span>;</code></td><td class="doc"><p>Optionally an ELF file, this may be used when running instructions on the state to provide more concrete values in certain case (like when reading from <code>.rodata</code>). It will affect the execution behavior. However the symbolic execution should always be more concrete with it than without it</p></td></tr><tr id="type-t.fenv" class="anchored"><td class="def field"><a href="#type-t.fenv" class="anchor"></a><code>fenv : <a href="../../State/Fragment/index.html#type-env">State.Fragment.env</a>;</code></td><td class="doc"><p>The memory type environment. See <a href="../Fragment/index.html#type-env"><code>Fragment.env</code></a></p></td></tr><tr id="type-t.last_pc" class="anchored"><td class="def field"><a href="#type-t.last_pc" class="anchor"></a><code><span class="keyword">mutable</span> last_pc : int;</code></td><td class="doc"><p>The PC of the instruction that lead into this state. The state should be right after that instruction. This has no semantic meaning as part of the state. It's just for helping knowing what comes from where</p></td></tr></table><code>}</code></dt><dd><p>Represent the state of the machine.</p><p>State are represented by their id and may identified to their id, they may not be two different state (and I mean physical equality here) with same id. See <a href="index.html#stateid"><span>State to id management</span></a>.</p><p>A first remark must be made about mutability: The type itself has an imperative interface, a lot of implicitly or explicitly mutable fields. However, Sometime immutable version of the state are required, so the state has a &quot;locking&quot; mechanism. When the <a href="index.html#type-t.locked"><code>locked</code></a> field, the state becomes immutable. This is unfortunately not enforced by the type system as that would require to have two different types. However all mutating functions assert that the state is unlocked before doing the mutation. The normal workflow with state is thus to create them unlocked, generaly by <a href="index.html#val-copy"><code>copy</code></a>ing another state, then mutate is to make a new interesting state, and then lock it so that it can be passed around for it's mathematical pure meaning. To lock a state, use the <a href="index.html#val-lock"><code>lock</code></a> function.</p><p>A second subtlety is that state are not represented in a standalone manner, They are represented as diff from a previous state, the <a href="index.html#type-t.base_state"><code>base_state</code></a>. In the idea, this state should be the immediate dominator of the current state in the control flow graph.However a state may not represent a full node of the control flow graph but only the part of that node that represent control-flow coming from specific paths. In that case the dominator notion is only about those paths.</p><p>Assertions (<a href="index.html#type-t.asserts"><code>asserts</code></a>) and memory (<a href="index.html#type-t.mem"><code>mem</code></a>) are represented as diffs from the base state. In particular all assertion constraining the base state are still constraining the child state.</p><p>This also implies a restriction on state dependent variables like <a href="Var/index.html#type-t.Register"><code>Var.t.Register</code></a>. The id of such variables can only be the id of the current state or one of it's ancestor. Further more if a variable of type <a href="Var/index.html#type-t.ReadVar"><code>Var.t.ReadVar</code></a> exists with and id and a number, then the <a href="index.html#type-t.read_vars"><code>read_vars</code></a> array of the state with that <code>id</code> must contain that number and the sizes must match. Those restriction are not only about semantic meaning but also more practical Ocaml Gc consideration, see <a href="index.html#stateid"><span>State to id management</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt></dl></section><section><header><h2 id="stateid"><a href="#stateid" class="anchor"></a>State to id management</h2><p>Each state has an id and the state can be refereed physically by id. This mean that there cannot be two different physical Ocaml state in the Gc memory that have the same id. Furthermore the <a href="index.html#val-id2state"><code>id2state</code></a> map is weak and so do not own the state. This means that possession of an id is the same as having a weak pointer to the state, except for two things:</p><ul><li>The id can be serialized and read to external program and files without losing it's meaning.</li><li>The id allow to break cyclical type dependency.</li></ul><p>This is in particular useful for variable that contain and id instead of a pointer to the state:</p><ul><li>The variable can be serialized in text manner to a SMT solver and keep their meaning.</li><li>The <a href="Var/index.html#type-t"><code>Var.t</code></a> type can be defined before the <a href="index.html#type-t"><code>t</code></a> type.</li></ul><p>That means that in theory a state could be Garbage collected while a variable still point to it. However a variable is only allowed to exists in a state if the id it points to is among the ancestors via the <a href="index.html#type-t.base_state"><code>base_state</code></a> relationship of the containing state. Since <a href="index.html#type-t.base_state"><code>base_state</code></a> is an GC-owning pointer, this ensure that while the containing state is alive, the variable target state is also alive.</p></header><dl><dt class="spec value" id="val-id2state"><a href="#val-id2state" class="anchor"></a><code><span class="keyword">val</span> id2state : <span><span>(<a href="index.html#type-id">id</a>,Â <a href="index.html#type-t">t</a>)</span> <a href="../../Utils/WeakMap/index.html#type-t">Utils.WeakMap.t</a></span></code></dt><dd><p>Global map of states to associate them with identifiers</p></dd></dl><dl><dt class="spec value" id="val-next_id"><a href="#val-next_id" class="anchor"></a><code><span class="keyword">val</span> next_id : <span><a href="index.html#type-id">id</a> Stdlib.ref</span></code></dt><dd><p>Next unused id</p></dd></dl><dl><dt class="spec value" id="val-of_id"><a href="#val-of_id" class="anchor"></a><code><span class="keyword">val</span> of_id : <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Get a state from its <code>id</code></p></dd></dl><dl><dt class="spec value" id="val-to_id"><a href="#val-to_id" class="anchor"></a><code><span class="keyword">val</span> to_id : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a></code></dt><dd><p>Get the id of a state</p></dd></dl></section><section><header><h2 id="state-management"><a href="#state-management" class="anchor"></a>State management</h2></header><dl><dt class="spec value" id="val-lock"><a href="#val-lock" class="anchor"></a><code><span class="keyword">val</span> lock : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Lock the state. Once a state is locked it should not be mutated anymore</p></dd></dl><dl><dt class="spec value" id="val-unsafe_unlock"><a href="#val-unsafe_unlock" class="anchor"></a><code><span class="keyword">val</span> unsafe_unlock : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Unlock the state. This is dangerous, do not use if you do not know how to use it, The only realistic use case, is for calling a simplifier and thus not changing the semantic meaning of the state in any way while mutating it.</p><p>This is deprecated and should disappear at some point.</p></dd></dl><dl><dt class="spec value" id="val-is_locked"><a href="#val-is_locked" class="anchor"></a><code><span class="keyword">val</span> is_locked : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Tell if the state is locked, in which case it shouldn't be mutated</p></dd></dl><dl><dt class="spec value" id="val-is_possible"><a href="#val-is_possible" class="anchor"></a><code><span class="keyword">val</span> is_possible : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Tell is state is possible.</p><p>A state is impossible if it has a single assert that is <code>false</code>. This means that this symbolic state represent the empty set of concrete states.</p><p><span class="xref-unresolved" title="unresolved reference to &quot;StateSimplify.ctxfull&quot;"><code>StateSimplify</code>.ctxfull</span> will call the SMT solver and set the assertions to that if required so you should call that function before <code>is_possible</code></p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <span>?&#8288;elf:<a href="../../Elf/File/index.html#type-t">Elf.File.t</a></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Makes a fresh state with all variable fresh and new. This fresh state is unlocked.</p><p>This should only be used by <code>Init</code>, all other state should be derived from <span class="xref-unresolved" title="unresolved reference to &quot;Init.state&quot;"><code>Init</code>.state</span>.</p></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : <span>?&#8288;elf:<a href="../../Elf/File/index.html#type-t">Elf.File.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Do a deep copy of all the mutable part of the state, so it can be mutated without retro-action.</p><p>If the source state is locked, then new state is based on it (in the sense of <a href="index.html#type-t.base_state"><code>t.base_state</code></a>), otherwise it is a literal copy of each field.</p><p>The returned state is always unlocked</p></dd></dl><dl><dt class="spec value" id="val-copy_if_locked"><a href="#val-copy_if_locked" class="anchor"></a><code><span class="keyword">val</span> copy_if_locked : <span>?&#8288;elf:<a href="../../Elf/File/index.html#type-t">Elf.File.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Copy the state with <a href="index.html#val-copy"><code>copy</code></a> if and only if it is locked. The returned state is always unlocked</p></dd></dl></section><section><header><h2 id="state-convenience-manipulation"><a href="#state-convenience-manipulation" class="anchor"></a>State convenience manipulation</h2></header><dl><dt class="spec value" id="val-push_assert"><a href="#val-push_assert" class="anchor"></a><code><span class="keyword">val</span> push_assert : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add an assertion to a state</p></dd></dl><dl><dt class="spec value" id="val-set_impossible"><a href="#val-set_impossible" class="anchor"></a><code><span class="keyword">val</span> set_impossible : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Set a state to be impossible (single <code>false</code> assert).</p></dd></dl><dl><dt class="spec value" id="val-set_asserts"><a href="#val-set_asserts" class="anchor"></a><code><span class="keyword">val</span> set_asserts : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-exp">exp</a> list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Set a state's <code>asserts</code></p></dd></dl><dl><dt class="spec value" id="val-map_mut_exp"><a href="#val-map_mut_exp" class="anchor"></a><code><span class="keyword">val</span> map_mut_exp : <span>(<a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Map a function on all the expressions of a state by mutating. This function, must preserve the semantic meaning of expression (like a simplification function) otherwise state invariants may be broken.</p></dd></dl><dl><dt class="spec value" id="val-iter_exp"><a href="#val-iter_exp" class="anchor"></a><code><span class="keyword">val</span> iter_exp : <span>(<a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterates a function on all the expressions of a state</p></dd></dl><dl><dt class="spec value" id="val-iter_var"><a href="#val-iter_var" class="anchor"></a><code><span class="keyword">val</span> iter_var : <span>(<a href="index.html#type-var">var</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterates a function on all the variables of a state</p></dd></dl></section><section><header><h2 id="state-memory-accessors"><a href="#state-memory-accessors" class="anchor"></a>State memory accessors</h2></header><dl><dt class="spec value" id="val-make_read"><a href="#val-make_read" class="anchor"></a><code><span class="keyword">val</span> make_read : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>?&#8288;ctyp:<a href="../../Ctype/index.html#type-t">Ctype.t</a></span> <span>&#45;&gt;</span> <a href="../../AstGen__Def/Size/index.html#type-t">Ast.Size.t</a> <span>&#45;&gt;</span> <a href="index.html#type-var">var</a></code></dt><dd><p>Create a new <a href="Var/index.html#type-t.ReadVar"><code>Var.t.ReadVar</code></a> by mutating the state</p></dd></dl><dl><dt class="spec value" id="val-set_read"><a href="#val-set_read" class="anchor"></a><code><span class="keyword">val</span> set_read : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Set a <a href="Var/index.html#type-t.ReadVar"><code>Var.t.ReadVar</code></a> to a specific value in <a href="index.html#type-t.read_vars"><code>t.read_vars</code></a></p></dd></dl><dl><dt class="spec value" id="val-read_from_rodata"><a href="#val-read_from_rodata" class="anchor"></a><code><span class="keyword">val</span> read_from_rodata : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>addr:<a href="index.html#type-exp">exp</a></span> <span>&#45;&gt;</span> <span>size:<a href="../../AstGen__Def/Size/index.html#type-t">Ast.Size.t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-exp">exp</a> option</span></code></dt><dd><p>Read memory from rodata</p></dd></dl><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <span>provenance:<a href="../../Ctype/index.html#type-provenance">Ctype.provenance</a></span> <span>&#45;&gt;</span> <span>?&#8288;ctyp:<a href="../../Ctype/index.html#type-t">Ctype.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>addr:<a href="index.html#type-exp">exp</a></span> <span>&#45;&gt;</span> <span>size:<a href="../../AstGen__Def/Size/index.html#type-t">Ast.Size.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p>Read the block designated by <code>addr</code> and <code>size</code> from the state and return an expression read. This will mutate the state to bind the read result to the newly created read variable.</p><p>The <code>ctyp</code> parameter may give a type to the read variable. This type is fully trusted and not checked in any way.</p><p>The expression could be either:</p><ul><li>An actual expression if the read could be resolved.</li><li>Just the symbolic read variable if the read couldn't be resolved</li></ul><p>This function is for case with <code>provenance</code> information is known.</p></dd></dl><dl><dt class="spec value" id="val-read_noprov"><a href="#val-read_noprov" class="anchor"></a><code><span class="keyword">val</span> read_noprov : <span>?&#8288;ctyp:<a href="../../Ctype/index.html#type-t">Ctype.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>addr:<a href="index.html#type-exp">exp</a></span> <span>&#45;&gt;</span> <span>size:<a href="../../AstGen__Def/Size/index.html#type-t">Ast.Size.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p>A wrapper around <a href="index.html#val-read"><code>read</code></a> for use when there is no provenance information. It may able to still perform the read under certain condition and otherwise will fail.</p></dd></dl><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val</span> write : <span>provenance:<a href="../../Ctype/index.html#type-provenance">Ctype.provenance</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>addr:<a href="index.html#type-exp">exp</a></span> <span>&#45;&gt;</span> <span>size:<a href="../../AstGen__Def/Size/index.html#type-t">Ast.Size.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write the provided value in the block. Mutate the state.</p></dd></dl><dl><dt class="spec value" id="val-write_noprov"><a href="#val-write_noprov" class="anchor"></a><code><span class="keyword">val</span> write_noprov : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>addr:<a href="index.html#type-exp">exp</a></span> <span>&#45;&gt;</span> <span>size:<a href="../../AstGen__Def/Size/index.html#type-t">Ast.Size.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>A wrapper around <a href="index.html#val-write"><code>write</code></a> for use when there is no provenance information. It may able to still perform the write under certain condition and otherwise will fail.</p></dd></dl></section><section><header><h2 id="state-register-accessors"><a href="#state-register-accessors" class="anchor"></a>State register accessors</h2></header><dl><dt class="spec value" id="val-reset_reg"><a href="#val-reset_reg" class="anchor"></a><code><span class="keyword">val</span> reset_reg : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>?&#8288;ctyp:<a href="../../Ctype/index.html#type-t">Ctype.t</a></span> <span>&#45;&gt;</span> <a href="../../State/Reg/index.html#type-t">State.Reg.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Reset the register to a symbolic value, and resets the type to the provided type (or no type if not provided)</p></dd></dl><dl><dt class="spec value" id="val-set_reg"><a href="#val-set_reg" class="anchor"></a><code><span class="keyword">val</span> set_reg : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../State/Reg/index.html#type-t">State.Reg.t</a> <span>&#45;&gt;</span> <a href="index.html#type-tval">tval</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets the content of register</p></dd></dl><dl><dt class="spec value" id="val-set_reg_type"><a href="#val-set_reg_type" class="anchor"></a><code><span class="keyword">val</span> set_reg_type : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../State/Reg/index.html#type-t">State.Reg.t</a> <span>&#45;&gt;</span> <a href="../../Ctype/index.html#type-t">Ctype.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets the type of the register, leaves the value unchanged</p></dd></dl><dl><dt class="spec value" id="val-get_reg"><a href="#val-get_reg" class="anchor"></a><code><span class="keyword">val</span> get_reg : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../State/Reg/index.html#type-t">State.Reg.t</a> <span>&#45;&gt;</span> <a href="index.html#type-tval">tval</a></code></dt><dd><p>Get the content of the register with it's type</p></dd></dl><dl><dt class="spec value" id="val-get_reg_exp"><a href="#val-get_reg_exp" class="anchor"></a><code><span class="keyword">val</span> get_reg_exp : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../State/Reg/index.html#type-t">State.Reg.t</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p>Get the content of the register without it's type</p></dd></dl><dl><dt class="spec value" id="val-update_reg_exp"><a href="#val-update_reg_exp" class="anchor"></a><code><span class="keyword">val</span> update_reg_exp : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../State/Reg/index.html#type-t">State.Reg.t</a> <span>&#45;&gt;</span> <span>(<a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Apply a function to a register. Leave the type intact</p></dd></dl></section><section><header><h2 id="pc-manipulation"><a href="#pc-manipulation" class="anchor"></a>Pc manipulation</h2></header><dl><dt class="spec value" id="val-set_pc"><a href="#val-set_pc" class="anchor"></a><code><span class="keyword">val</span> set_pc : <span>pc:<a href="../../State/Reg/index.html#type-t">State.Reg.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Set the PC to a concrete value and keep its type appropriate</p></dd></dl><dl><dt class="spec value" id="val-bump_pc"><a href="#val-bump_pc" class="anchor"></a><code><span class="keyword">val</span> bump_pc : <span>pc:<a href="../../State/Reg/index.html#type-t">State.Reg.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Bump a concrete PC by a concrete bump (generally the size of a non-branching instruction</p></dd></dl><dl><dt class="spec value" id="val-concretize_pc"><a href="#val-concretize_pc" class="anchor"></a><code><span class="keyword">val</span> concretize_pc : <span>pc:<a href="../../State/Reg/index.html#type-t">State.Reg.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Try to evaluate the PC if it is concrete</p></dd></dl><dl><dt class="spec value" id="val-set_last_pc"><a href="#val-set_last_pc" class="anchor"></a><code><span class="keyword">val</span> set_last_pc : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Set the <code>last_pc</code> of the state</p></dd></dl></section><section><header><h2 id="pretty-printing"><a href="#pretty-printing" class="anchor"></a>Pretty printing</h2></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> PPrintEngine.document</code></dt><dt class="spec value" id="val-pp_partial"><a href="#val-pp_partial" class="anchor"></a><code><span class="keyword">val</span> pp_partial : <span>regs:<span><a href="../../State/Reg/index.html#type-t">State.Reg.t</a> list</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> PPrintEngine.document</code></dt><dd><p>Print only the mentioned regs and the memory and asserts since the base_state. Until a better solution is found, the fenv will be printed entirely all the time</p></dd></dl></section></div></body></html>