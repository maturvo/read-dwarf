<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>SymbolicExpressions (read-dwarf.SymbolicExpressions)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="index.html">Up</a> â€“ <a href="index.html">read-dwarf</a> &#x00BB; SymbolicExpressions</nav><h1 id="symbolic-expressions"><a href="#symbolic-expressions" class="anchor"></a>Symbolic Expressions</h1><nav class="toc"><ul><li><a href="#expression-representation-and-parametric-types">Expression representation and parametric types</a><ul><li><a href="#build-process-and-modules">Build process and modules</a></li><li><a href="#typopt">Expression type parameter and options</a></li></ul></li><li><a href="#operations-on-expressions">Operations on expressions</a></li><li><a href="#symbolic-regions-of-memory">Symbolic regions of memory</a></li></ul></nav></header><h2 id="expression-representation-and-parametric-types"><a href="#expression-representation-and-parametric-types" class="anchor"></a>Expression representation and parametric types</h2><p>The internal expression syntax is derived from <a href="http://smtlib.cs.uiowa.edu/">SMT-LIB</a> with the bitvector, boolean, and enumeration theory. The enumeration theory is about types that contain a specific number of numbered item. All the symbolic execution system is based of those expressions.</p><p>Optionally, an expression can support the whole memory through the SMT array theory from addresses to bytes or words. This support is optional, see <a href="SymbolicExpressions.html#typopt"><span>Expression type parameter and options</span></a></p><p>If you only wish to use those expression, I recommend you directly use the <a href="Ast/index.html"><code>Ast</code></a> module. This module export <a href="Ast/index.html#type-exp"><code>Ast.exp</code></a> as well as parsing and pretty printing capabilities.</p><p>The <a href="Ast/index.html"><code>Ast</code></a> module also define the syntax for SMT-LIB commands (<a href="Ast/index.html#type-smt"><code>Ast.smt</code></a>), and answers (<a href="Ast/index.html#type-smt_ans"><code>Ast.smt_ans</code></a>).</p><h3 id="build-process-and-modules"><a href="#build-process-and-modules" class="anchor"></a>Build process and modules</h3><p>The expressions types are build by <code>ott</code>. Currently, to avoid repetition, part of the <code>ott</code> AST comes from <code>isla_lang.ott</code> and only the difference with <code>isla-lang</code> are coming from the main <code>ast.ott</code> file. Only specific parts of <code>isla_lang.ott</code> are extracted with <code>extract_section.awk</code> before merging with <code>ast.ott</code>. The result of the call to <code>ott</code> are:</p><ul><li><a href="AstGen/Ott/index.html"><code>AstGen.Ott</code></a> that defined the ast types</li><li><a href="AstGen/Parser/index.html"><code>AstGen.Parser</code></a> The menhir parser module</li><li><a href="AstGen/Parser_pp/index.html"><code>AstGen.Parser_pp</code></a> The pprint pretty-printing module</li><li><a href="AstGen/Lexer/index.html"><code>AstGen.Lexer</code></a> The ocamllex lexer module</li></ul><p>One thing to be aware of is the dependency chain: first <a href="AstGen/Ott/index.html"><code>AstGen.Ott</code></a> is defined, then <a href="AstGen/Def/index.html"><code>AstGen.Def</code></a> (which is not generated) defines dome extra type definition to be used, then all the parsing and pretty printing module depend on <a href="AstGen/Def/index.html"><code>AstGen.Def</code></a> and then <a href="Ast/index.html"><code>Ast</code></a> encapsulates all of that for the rest of the codebase.</p><p>Unless you are tweaking things inside the AST, you should only use the <a href="Ast/index.html"><code>Ast</code></a> module.</p><h3 id="typopt"><a href="#typopt" class="anchor"></a>Expression type parameter and options</h3><p>The type of expression (<a href="Ast/index.html#type-exp"><code>Ast.exp</code></a>) is parametric and has currently 4 parameters that are propagated to other <a href="Ast/index.html"><code>Ast</code></a> types. Some <a href="Ast/index.html"><code>Ast</code></a> types only have a subset of those parameters when it make sense. It would be good to respect the variable letter names throughout the codebase to keep it consistent and understandable.</p><ul><li><code>'a</code>: Annotation type: The annotation is present on every expression constructor, and can be extracted with <span class="xref-unresolved" title="unresolved reference to &quot;Ast.Manip.annot&quot;"><a href="Ast/index.html#module-Manip"><code>Ast.Manip</code></a>.annot</span></li><li><code>'v</code>: Variable type: The type of symbolic variables.</li><li><code>'b</code>: Bound variable type: The expression can optionally contain let bindings and bound variables with the usual semantics. This feature of expression can be disabled by putting <a href="Ast/index.html#type-no"><code>Ast.no</code></a> in that parameter slot, in which case all let-bindings constructors and bound variable (<code>Let</code> and <code>Bound</code>) are disabled.</li><li><code>'m</code>: Memory operation: This is intended to be a boolean option: only <a href="Ast/Size/index.html#type-t"><code>Ast.Size.t</code></a> or <a href="Ast/index.html#type-no"><code>Ast.no</code></a>. In the first case, expression are allowed to contain memory array type and contain constructors like memory select or store. In the second case, all those operations are disabled and it is known that an expression can only be a bitvector, a boolean or an enumeration. In particular the content of register should generally not contain memory-enabled expressions.</li></ul><p>Expression coming out of the parser have their type parameter fixed to <code>'a=</code><a href="Ast/index.html#type-lrng"><code>Ast.lrng</code></a>, <code>'v=string</code>, <code>'b=string</code>, <code>'m=</code><a href="Ast/Size/index.html#type-t"><code>Ast.Size.t</code></a>. Corresponding aliases of the various instanciation with those type are types prefixed by <code>r</code> like <a href="Ast/index.html#type-rexp"><code>Ast.rexp</code></a>, <a href="Ast/index.html#type-rsmt"><code>Ast.rsmt</code></a>, <a href="Ast/index.html#type-rty"><code>Ast.rty</code></a>, and <a href="Ast/index.html#type-rsmt_ans"><code>Ast.rsmt_ans</code></a>.</p><p>The pretty-printer functions are a bit more tolerant in which type are allowed, but there still are some restrictions. Thus one may need to use some of the conversion function in next section before pretty-printing or after parsing.</p><h2 id="operations-on-expressions"><a href="#operations-on-expressions" class="anchor"></a>Operations on expressions</h2><p>Basic operation on expression like mapping/iterating over sub-expresions or variables is provided in <a href="Ast/Manip/index.html"><code>Ast.Manip</code></a>. This module also provide conversion of type parameters (like changing the type of variables).</p><p>Internally, typed expression are used, which mean that the <code>'a</code> parameter of the expressions is actually their type of ocaml type <a href="Ast/index.html#type-ty"><code>Ast.ty</code></a>. The <a href="Exp/Typed/index.html"><code>Exp.Typed</code></a> module provide smart constructors that allow to construct directly typed expressions. It also provide function to convert untyped expression to typed expressions. On top of that the <a href="Exp/index.html"><code>Exp</code></a> module provides a functor to apply over a variable functor that allow to lift variable behavior like equality and pretty printing at the expression level.</p><p><a href="Ast/Manip/index.html"><code>Ast.Manip</code></a> only provide syntactic operation on expression, other modules provide semantic operations on expressions:</p><ul><li><a href="Exp/Sums/index.html"><code>Exp.Sums</code></a> provide sum manipulation: allow to split and rebuild sum expression to/from list of terms.</li><li><a href="Exp/ConcreteEval/index.html"><code>Exp.ConcreteEval</code></a> provides concrete evaluation of expressions. It returns values of type <a href="Exp__/Value/index.html#type-t"><code>Exp.Value.t</code></a> which represent the possible concrete values that can result of an expression evaluation.</li><li><a href="Exp/PpExp/index.html"><code>Exp.PpExp</code></a> provide a more human readable expression printing than SMT-LIB syntax. Most operator are infix and have &quot;usual&quot; precedence. This module try to stay injective which means that a given pretty printed text represent a single possible syntactic expression.</li><li>And last but not least: <a href="Z3/index.html"><code>Z3</code></a> module allow interacting with Z3 for simplifying expression and checking SMT properties. If you use the high-level API of this module, you will not have to care about types like <a href="Ast/index.html#type-smt"><code>Ast.smt</code></a> or <a href="Ast/index.html#type-smt_ans"><code>Ast.smt_ans</code></a>.</li></ul><h2 id="symbolic-regions-of-memory"><a href="#symbolic-regions-of-memory" class="anchor"></a>Symbolic regions of memory</h2><p>In symbolic execution, one may need to represent large regions of memory in a symbolic manner. It would be possible to do that with a single expression of bitvector type with a very large size but this quickly become unwieldy. Furthermore in some case the machine code will perform writes at symbolic address which the position at which something is written in something else is symbolic. To represent this we use a two stage abstraction.</p><p>First, there is <a href="State/SymbolicBytes/index.html"><code>State.SymbolicBytes</code></a> which represent a block of memory which can contain arbitrary symbolic expressions at arbitrary but concrete addresses. Then <span class="xref-unresolved" title="unresolved reference to &quot;State.SymbolicFragment&quot;"><a href="State/index.html"><code>State</code></a>.SymbolicFragment</span> takes it one step further and provide a way to store arbitrary symbolic expressions at arbitrary symbolic addresses. When reading from a <span class="xref-unresolved" title="unresolved reference to &quot;State.SymbolicFragment&quot;"><a href="State/index.html"><code>State</code></a>.SymbolicFragment</span>, the read may not be resolved because of unknown aliasing of symbolic addresses. Those abstractions are only suitable to represent a sequential view of the memory without any concept of concurrent memory accesses.</p></div></body></html>