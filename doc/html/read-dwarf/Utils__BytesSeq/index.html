<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Utils__BytesSeq (read-dwarf.Utils__BytesSeq)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">read-dwarf</a> &#x00BB; Utils__BytesSeq</nav><h1>Module <code>Utils__BytesSeq</code></h1><p>This module represent a byte sub view on a <code>bytes</code> object. Contrary to <code>Bytes</code> it is a non-owning immutable view. It do not prevent the original bytes from being modified, and the changes will be propagated in the view. It is additional sugar on top of Linksem's <code>Byte_sequence_wrapper</code></p><p>About all the suffixed function:</p><ul><li>All iteration function without suffix do the expected operation on char (as single bytes)</li><li>All iteration function with suffix nle do the expected operation on a sequence of integers of n bits as read in little endian.</li><li>All iteration function with suffix nbe do the expected operation on a sequence of integers of n bits as read in big endian.</li><li>All iteration function with suffix bs do the expected operation on a sequence of BytesSeq.t of specified length.</li><li>All iteration function with suffix bvle do the expected operation on a sequence of <code>BitVec</code> the specified <code>size</code> as read in little endian.</li></ul><nav class="toc"><ul><li><a href="#hexadecimal-conversions">Hexadecimal conversions</a></li><li><a href="#cutting-the-view">Cutting the view</a></li><li><a href="#interaction-with-bytes-and-raw-string">Interaction with <code>bytes</code> and raw string</a></li><li><a href="#array-conversions">Array conversions</a></li><li><a href="#getters">Getters</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#list-conversions">List conversions</a></li><li><a href="#binary-io">Binary IO</a></li><li><a href="#pretty-printing">Pretty Printing</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = Byte_sequence_wrapper.byte_sequence</code></dt><dd><p>Type inherited from <code>linksem</code></p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Get the length of the byteseq in bytes</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check if two byte sequence are equal byte for byte</p></dd></dl><dl><dt class="spec value" id="val-int_bytes"><a href="#val-int_bytes" class="anchor"></a><code><span class="keyword">val</span> int_bytes : int</code></dt><dd><p>The size in bytes of an Ocaml int</p></dd></dl><section><header><h2 id="hexadecimal-conversions"><a href="#hexadecimal-conversions" class="anchor"></a>Hexadecimal conversions</h2></header><dl><dt class="spec value" id="val-to_hex"><a href="#val-to_hex" class="anchor"></a><code><span class="keyword">val</span> to_hex : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Convert the byte sequence to an hexadecimal string</p></dd></dl><dl><dt class="spec value" id="val-to_hex_rev"><a href="#val-to_hex_rev" class="anchor"></a><code><span class="keyword">val</span> to_hex_rev : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Convert the byte sequence to an reversed hexadecimal string. This will print it like a big-endian integer.</p></dd></dl><dl><dt class="spec value" id="val-of_hex"><a href="#val-of_hex" class="anchor"></a><code><span class="keyword">val</span> of_hex : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Parse the string as hexadecimal like A4B767DF and create a bytes of this a binary data and then a bytesSeq view of it</p></dd></dl></section><section><header><h2 id="cutting-the-view"><a href="#cutting-the-view" class="anchor"></a>Cutting the view</h2></header><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sub bs start len</code> Extract a sub range <code>[start:start+len)</code> of a byte sequence. This is O(1)</p></dd></dl><dl><dt class="spec value" id="val-front"><a href="#val-front" class="anchor"></a><code><span class="keyword">val</span> front : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>front i bs</code> Take the first <code>i</code> bytes of <code>bs</code> and discard the rest. Equivalent to <code>sub bs 0 i</code></p></dd></dl><dl><dt class="spec value" id="val-back"><a href="#val-back" class="anchor"></a><code><span class="keyword">val</span> back : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>back i bs</code> Take the last <code>i</code> bytes of <code>bs</code> and discard the rest. Equivalent to <code>sub bs i (length bs - i)</code></p></dd></dl></section><section><header><h2 id="interaction-with-bytes-and-raw-string"><a href="#interaction-with-bytes-and-raw-string" class="anchor"></a>Interaction with <code>bytes</code> and raw string</h2></header><dl><dt class="spec value" id="val-blit"><a href="#val-blit" class="anchor"></a><code><span class="keyword">val</span> blit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from bytes sequence <code>src</code>, starting at index <code>srcoff</code>, to bytes <code>dst</code>, starting at index <code>dstoff</code>.</p><p>See <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Bytes.html#VALblit"><code>Bytes.blit</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-of_bytes"><a href="#val-of_bytes" class="anchor"></a><code><span class="keyword">val</span> of_bytes : bytes <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a view of the whole bytes</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a view of the whole string as raw bytes</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Create a copy of the view in a string</p></dd></dl><dl><dt class="spec value" id="val-bytes_sub"><a href="#val-bytes_sub" class="anchor"></a><code><span class="keyword">val</span> bytes_sub : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a byte sequence view of a specified range of a bytes. See <a href="index.html#val-sub"><code>sub</code></a></p></dd></dl></section><section><header><h2 id="array-conversions"><a href="#array-conversions" class="anchor"></a>Array conversions</h2></header><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>char array</span></code></dt><dd><p>Convert to a char array</p></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : <span>char array</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Convert from a char array</p></dd></dl></section><section><header><h2 id="getters"><a href="#getters" class="anchor"></a>Getters</h2></header><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char</code></dt><dd><p>Get the bytes at the offset in the byte sequence</p></dd></dl><dl><dt class="spec value" id="val-unsafe_get"><a href="#val-unsafe_get" class="anchor"></a><code><span class="keyword">val</span> unsafe_get : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char</code></dt><dd><p>Unsafe version of <a href="index.html#val-get"><code>get</code></a></p></dd></dl><dl><dt class="spec value" id="val-get16le"><a href="#val-get16le" class="anchor"></a><code><span class="keyword">val</span> get16le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p>Get a 16 bit integer at the offset in the byte sequence as little endian</p></dd></dl><dl><dt class="spec value" id="val-get16be"><a href="#val-get16be" class="anchor"></a><code><span class="keyword">val</span> get16be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p>Get a 16 bit integer at the offset in the byte sequence as big endian</p></dd></dl><dl><dt class="spec value" id="val-get32le"><a href="#val-get32le" class="anchor"></a><code><span class="keyword">val</span> get32le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int32</code></dt><dd><p>Get a 32 bit integer at the offset in the byte sequence as little endian</p></dd></dl><dl><dt class="spec value" id="val-get32be"><a href="#val-get32be" class="anchor"></a><code><span class="keyword">val</span> get32be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int32</code></dt><dd><p>Get a 32 bit integer at the offset in the byte sequence as big endian</p></dd></dl><dl><dt class="spec value" id="val-get64le"><a href="#val-get64le" class="anchor"></a><code><span class="keyword">val</span> get64le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int64</code></dt><dd><p>Get a 64 bit integer at the offset in the byte sequence as little endian</p></dd></dl><dl><dt class="spec value" id="val-get64be"><a href="#val-get64be" class="anchor"></a><code><span class="keyword">val</span> get64be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int64</code></dt><dd><p>Get a 64 bit integer at the offset in the byte sequence as big endian</p></dd></dl><dl><dt class="spec value" id="val-getintle"><a href="#val-getintle" class="anchor"></a><code><span class="keyword">val</span> getintle : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p>Get an Ocaml int at the offset in the byte sequence as little endian. The number of bytes read is 4 if <code>Sys.int_size</code> is 31 and 8 if <code>Sys.int_size</code> is 63</p></dd></dl><dl><dt class="spec value" id="val-getbs"><a href="#val-getbs" class="anchor"></a><code><span class="keyword">val</span> getbs : <span>len:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Get a byte sequence of length <code>len</code> at the offset in another byte sequence</p></dd></dl><dl><dt class="spec value" id="val-getbvle"><a href="#val-getbvle" class="anchor"></a><code><span class="keyword">val</span> getbvle : <span>size:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Utils/BitVec/index.html#type-t">Utils.BitVec.t</a></code></dt><dd><p>Get a <code>BitVec</code> of size <code>size</code> at the offset in the byte sequence as little endian</p></dd></dl><dl><dt class="spec value" id="val-getintle_ze"><a href="#val-getintle_ze" class="anchor"></a><code><span class="keyword">val</span> getintle_ze : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p>Get an Ocaml int at the offset in the byte sequence as little endian. The number of bytes read is 4 if <code>Sys.int_size</code> is 31 and 8 if <code>Sys.int_size</code> is 63. If the read goes beyond the end of the sequence, instead of failing, zeros are read.</p></dd></dl></section><section><header><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2><p>Iterators over a byte sequence. If the length of the byte sequence is not a multiple of the step of the iteration then the trailing odd bytes are not iterated over.</p></header><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(char <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-iter16le"><a href="#val-iter16le" class="anchor"></a><code><span class="keyword">val</span> iter16le : <span>(int <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-iter16be"><a href="#val-iter16be" class="anchor"></a><code><span class="keyword">val</span> iter16be : <span>(int <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-iter32le"><a href="#val-iter32le" class="anchor"></a><code><span class="keyword">val</span> iter32le : <span>(int32 <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-iter32be"><a href="#val-iter32be" class="anchor"></a><code><span class="keyword">val</span> iter32be : <span>(int32 <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-iter64le"><a href="#val-iter64le" class="anchor"></a><code><span class="keyword">val</span> iter64le : <span>(int64 <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-iter64be"><a href="#val-iter64be" class="anchor"></a><code><span class="keyword">val</span> iter64be : <span>(int64 <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-iterbs"><a href="#val-iterbs" class="anchor"></a><code><span class="keyword">val</span> iterbs : <span>len:int</span> <span>&#45;&gt;</span> <span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate over the byte sequence by bytesequence of length <code>len</code>. If the total byte sequence is not of length a multiple of <code>len</code> then that iterated value will be shorter</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_left16le"><a href="#val-fold_left16le" class="anchor"></a><code><span class="keyword">val</span> fold_left16le : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_left16be"><a href="#val-fold_left16be" class="anchor"></a><code><span class="keyword">val</span> fold_left16be : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_left32le"><a href="#val-fold_left32le" class="anchor"></a><code><span class="keyword">val</span> fold_left32le : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int32 <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_left32be"><a href="#val-fold_left32be" class="anchor"></a><code><span class="keyword">val</span> fold_left32be : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int32 <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_left64le"><a href="#val-fold_left64le" class="anchor"></a><code><span class="keyword">val</span> fold_left64le : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_left64be"><a href="#val-fold_left64be" class="anchor"></a><code><span class="keyword">val</span> fold_left64be : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_leftbs"><a href="#val-fold_leftbs" class="anchor"></a><code><span class="keyword">val</span> fold_leftbs : <span>len:int</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl></section><section><header><h2 id="list-conversions"><a href="#list-conversions" class="anchor"></a>List conversions</h2></header><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>char list</span></code></dt><dt class="spec value" id="val-to_list16le"><a href="#val-to_list16le" class="anchor"></a><code><span class="keyword">val</span> to_list16le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>int list</span></code></dt><dt class="spec value" id="val-to_list16be"><a href="#val-to_list16be" class="anchor"></a><code><span class="keyword">val</span> to_list16be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>int list</span></code></dt><dt class="spec value" id="val-to_list32le"><a href="#val-to_list32le" class="anchor"></a><code><span class="keyword">val</span> to_list32le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>int32 list</span></code></dt><dt class="spec value" id="val-to_list32be"><a href="#val-to_list32be" class="anchor"></a><code><span class="keyword">val</span> to_list32be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>int32 list</span></code></dt><dt class="spec value" id="val-to_list64le"><a href="#val-to_list64le" class="anchor"></a><code><span class="keyword">val</span> to_list64le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>int64 list</span></code></dt><dt class="spec value" id="val-to_list64be"><a href="#val-to_list64be" class="anchor"></a><code><span class="keyword">val</span> to_list64be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>int64 list</span></code></dt><dt class="spec value" id="val-to_listbs"><a href="#val-to_listbs" class="anchor"></a><code><span class="keyword">val</span> to_listbs : <span>len:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span></code></dt><dd><p>Cut a byte sequence into a list of byte sequences of length <code>len</code>, (and a shorter last one if the total len is not a multiple of len)</p></dd></dl></section><section><header><h2 id="binary-io"><a href="#binary-io" class="anchor"></a>Binary IO</h2></header><dl><dt class="spec value" id="val-output"><a href="#val-output" class="anchor"></a><code><span class="keyword">val</span> output : Stdlib.out_channel <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Output the raw data of the byte sequence on the output channel</p></dd></dl><dl><dt class="spec value" id="val-input"><a href="#val-input" class="anchor"></a><code><span class="keyword">val</span> input : Stdlib.in_channel <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Output the raw date of the byte sequence of the input channel</p></dd></dl></section><section><header><h2 id="pretty-printing"><a href="#pretty-printing" class="anchor"></a>Pretty Printing</h2></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Pretty print a byte sequence as space separated bytes like <code>ab cd ef</code>.</p><p>Here &quot;ab&quot; is the byte number 0 and &quot;ef&quot; is the byte number 2.</p></dd></dl><dl><dt class="spec value" id="val-ppc"><a href="#val-ppc" class="anchor"></a><code><span class="keyword">val</span> ppc : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Pretty print a byte sequence as an hexadecimal string like <code>abcdef</code></p><p>Here &quot;ab&quot; is the byte number 0 and &quot;ef&quot; is the byte number 2.</p><p>This can also be seen as printing the bytesequence as a single integer encoded in big endian format.</p></dd></dl><dl><dt class="spec value" id="val-ppint"><a href="#val-ppint" class="anchor"></a><code><span class="keyword">val</span> ppint : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Pretty print a byte sequence as an hexadecimal integer (in little endian). The byte order is reversed compared to <a href="index.html#val-ppc"><code>ppc</code></a></p><p>For example the byte sequence <code>ab cd ef</code> will be printed as <code>efcdab</code> where &quot;ab&quot; is the byte number 0 and &quot;ef&quot; is the byte number 2.</p></dd></dl><dl><dt class="spec value" id="val-ppby"><a href="#val-ppby" class="anchor"></a><code><span class="keyword">val</span> ppby : <span>by:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Pretty print a byte sequence by step of <code>by</code> bytes. Each block is pretty printed as an hex string like <a href="index.html#val-ppc"><code>ppc</code></a> and blocks are separated by spaces.</p></dd></dl><dl><dt class="spec value" id="val-ppbyint"><a href="#val-ppbyint" class="anchor"></a><code><span class="keyword">val</span> ppbyint : <span>by:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Pretty print a byte sequence by step of <code>by</code> bytes. Each block is pretty printed as a reversed hex string i.e like an integer of length <code>by</code>. Thus each block will printed like with <code>ppcint</code> Blocks are separated by spaces.</p><p>For example to print a byte sequence as a space separated list of little-endian integers do:</p><pre><code class="ml">ppbyint ~by:4 bs</code></pre></dd></dl></section></div></body></html>