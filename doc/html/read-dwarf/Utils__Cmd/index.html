<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Utils__Cmd (read-dwarf.Utils__Cmd)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">read-dwarf</a> &#x00BB; Utils__Cmd</nav><h1>Module <code>Utils__Cmd</code></h1><p>This module provides high-level interaction with external processes.</p><p>This provide a functionality similar to <a href="https://erratique.ch/software/bos/doc/Bos.html"><code>Bos</code>)</a>, but this lib is still unstable.</p><p>There are two main mode of communication provided:</p><ul><li>Interaction with pipes: capture the stdin or stdout of the command and use them</li><li>Interaction with socket: Create a socket on which the child program can connect to.</li></ul><p>Programs can be launched in two modes</p><ul><li>Calling: They are called like a function and we wait for them to give a result before contnuing</li><li>Server: The are launch as a background process that stay there and can be called.</li></ul><p>Calling programs can be done with <code>call*</code> function like <a href="index.html#val-call"><code>call</code></a>, <a href="index.html#val-call_read"><code>call_read</code></a>, <a href="index.html#val-call_send"><code>call_send</code></a> and <a href="index.html#val-call_send_read"><code>call_send_read</code></a> and only support pipe interaction</p><p>Server like setups can be done in pipe mode with <a href="IOServer/index.html"><code>IOServer</code></a> and in socket mode with <a href="SocketServer/index.html"><code>SocketServer</code></a>.</p><nav class="toc"><ul><li><a href="#pipe-calling">Pipe calling</a></li><li><a href="#pipe-server">Pipe server</a></li><li><a href="#socket-server">Socket server</a></li></ul></nav></header><dl><dt class="spec type" id="type-cmd"><a href="#type-cmd" class="anchor"></a><code><span class="keyword">type</span> cmd</code><code> = <span>string array</span></code></dt><dd><p>The type of a command to be sent. The program to call must be the item 0 of the array</p></dd></dl><dl><dt class="spec exception" id="exception-Crash"><a href="#exception-Crash" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Crash</span> <span class="keyword">of</span> <a href="index.html#type-cmd">cmd</a> * Unix.process_status</code></dt><dd><p>If a program do not return with a 0 exit code, we throw that exception giving the command that failed and the invalid status it returned</p></dd></dl><section><header><h2 id="pipe-calling"><a href="#pipe-calling" class="anchor"></a>Pipe calling</h2></header><dl><dt class="spec value" id="val-call"><a href="#val-call" class="anchor"></a><code><span class="keyword">val</span> call : <a href="index.html#type-cmd">cmd</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Call the command without redirecting anything. Wait for completion before returning.</p><p>May throw <a href="index.html#exception-Crash"><code>Crash</code></a> on error.</p></dd></dl><dl><dt class="spec value" id="val-call_send"><a href="#val-call_send" class="anchor"></a><code><span class="keyword">val</span> call_send : <a href="index.html#type-cmd">cmd</a> <span>&#45;&gt;</span> <span>sender:<span>(Stdlib.out_channel <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Call the command and then call <code>sender</code> to send it some data on it's <code>stdin</code>. Then wait for completion.</p><p>May throw <a href="index.html#exception-Crash"><code>Crash</code></a> on error.</p></dd></dl><dl><dt class="spec value" id="val-call_send_string"><a href="#val-call_send_string" class="anchor"></a><code><span class="keyword">val</span> call_send_string : <a href="index.html#type-cmd">cmd</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Call the command, send it the string on it's standard input and wait for completion.</p><p>May throw <a href="index.html#exception-Crash"><code>Crash</code></a> on error.</p></dd></dl><dl><dt class="spec value" id="val-call_read"><a href="#val-call_read" class="anchor"></a><code><span class="keyword">val</span> call_read : <a href="index.html#type-cmd">cmd</a> <span>&#45;&gt;</span> <span>reader:<span>(Stdlib.in_channel <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Call the command and then call <code>reader</code> to parse what the command outputs on it's <code>stdout</code>. Then wait for completion and return the parsed value</p><p>May throw <a href="index.html#exception-Crash"><code>Crash</code></a> on error.</p></dd></dl><dl><dt class="spec value" id="val-call_read_string"><a href="#val-call_read_string" class="anchor"></a><code><span class="keyword">val</span> call_read_string : <a href="index.html#type-cmd">cmd</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Call the command, wait for completion, and return it's <code>stdout</code> in a string</p></dd></dl><dl><dt class="spec value" id="val-call_send_read"><a href="#val-call_send_read" class="anchor"></a><code><span class="keyword">val</span> call_send_read : <a href="index.html#type-cmd">cmd</a> <span>&#45;&gt;</span> <span>sender:<span>(Stdlib.out_channel <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>reader:<span>(Stdlib.in_channel <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Call the command and then call <code>sender</code> to send the input data on it's <code>stdin</code>. Then call <code>reader</code> to parse an answer from <code>stdout</code> Then wait for completion and return the parsed value</p><p>May throw <a href="index.html#exception-Crash"><code>Crash</code></a> on error.</p></dd></dl></section><section><header><h2 id="pipe-server"><a href="#pipe-server" class="anchor"></a>Pipe server</h2></header><dl><dt class="spec module" id="module-IOServer"><a href="#module-IOServer" class="anchor"></a><code><span class="keyword">module</span> <a href="IOServer/index.html">IOServer</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This module provide functionality to run command in the background and communicate with it via redirection on it's standard input and output.</p></dd></dl></section><section><header><h2 id="socket-server"><a href="#socket-server" class="anchor"></a>Socket server</h2></header><dl><dt class="spec module" id="module-SocketServer"><a href="#module-SocketServer" class="anchor"></a><code><span class="keyword">module</span> <a href="SocketServer/index.html">SocketServer</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This module provide functionality for a socket server with which one can communicate on a sockets.</p></dd></dl></section></div></body></html>