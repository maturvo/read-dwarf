<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Utils__FullVec (read-dwarf.Utils__FullVec)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">read-dwarf</a> &#x00BB; Utils__FullVec</nav><h1>Module <code>Utils__FullVec</code></h1><p>A full vector is a vector in which all non-negative integer are bound.</p><p>This consist in a normal vector and a function and all the bindings of value after the vector end are the result of the function call on that integer.</p><p>It is guaranted that the function will be called lazily on integer when required in stricly increasing order (and thus never twice on the same integer). However an integer may be skipped (When manually set). That means the function can have side effect if necessary. However if the structure is copied (<a href="index.html#val-map"><code>map</code></a> or <a href="index.html#val-copy"><code>copy</code></a>), The generator may be called multiple time on some integer in the different copies.</p><p>Both set and get may generate calls to the generator if required.</p><p>Any attempt to use a negative integer will raise <code>Invalid_argument</code>.</p><p>A negative integer will never be passed to the generator.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Create a full vector from a generator</p></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Make a copy that can be mutated separately</p></dd></dl><dl><dt class="spec value" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val</span> set : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Set the binding of that integer</p></dd></dl><dl><dt class="spec value" id="val-set_after"><a href="#val-set_after" class="anchor"></a><code><span class="keyword">val</span> set_after : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Set the binding of all integer after this value by supplying a new generator. The former generator is discarded. The bindings before the value keep their value (if there were not generated, they will be before discarding the old generator</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Get the binding of that integer</p></dd></dl><dl><dt class="spec value" id="val-get_vec"><a href="#val-get_vec" class="anchor"></a><code><span class="keyword">val</span> get_vec : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Utils/Vec/index.html#type-t">Utils.Vec.t</a></span></code></dt><dd><p>Get the underlying vector</p></dd></dl><dl><dt class="spec value" id="val-get_vec_until"><a href="#val-get_vec_until" class="anchor"></a><code><span class="keyword">val</span> get_vec_until : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Utils/Vec/index.html#type-t">Utils.Vec.t</a></span></code></dt><dd><p>Get a vector containing at least the elements until the specified value excluded</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Map the function over the fullvec. Postcompose the map on the generator</p></dd></dl><dl><dt class="spec value" id="val-map_mut"><a href="#val-map_mut" class="anchor"></a><code><span class="keyword">val</span> map_mut : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Map the function over the fullvector by mutation. Postcompose the map on the generator.contents Warning, a lot of <a href="index.html#val-map_mut"><code>map_mut</code></a> may make the generator big and slow. Maybe try to use <a href="index.html#val-set_after"><code>set_after</code></a> to reset it when required.</p></dd></dl><dl><dt class="spec value" id="val-map_mut_until"><a href="#val-map_mut_until" class="anchor"></a><code><span class="keyword">val</span> map_mut_until : <span>limit:int</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Map the function over the fullvector until the limit. The rest is unchanged</p></dd></dl><dl><dt class="spec value" id="val-iter_until"><a href="#val-iter_until" class="anchor"></a><code><span class="keyword">val</span> iter_until : <span>limit:int</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate until the specified value (excluded). (The FullVec is infinite so you can't iter on all of it)</p></dd></dl><dl><dt class="spec value" id="val-iteri_until"><a href="#val-iteri_until" class="anchor"></a><code><span class="keyword">val</span> iteri_until : <span>limit:int</span> <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="index.html#val-iter_until"><code>iter_until</code></a> but with the index</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../Utils/index.html#module-Pp">Utils.Pp</a>.document</code></dt><dd><p>Only prints the non-default values</p></dd></dl></div></body></html>