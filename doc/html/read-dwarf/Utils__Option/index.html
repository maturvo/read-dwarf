<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Utils__Option (read-dwarf.Utils__Option)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">read-dwarf</a> &#x00BB; Utils__Option</nav><h1>Module <code>Utils__Option</code></h1><p>This module extends the base OCaml API of <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Option.html"><code>Option</code></a>.</p><p>In particular, it adds:</p><ul><li>Monadic bindings</li><li>Option merging</li><li>Option lifting of list and pairs.</li></ul><nav class="toc"><ul><li><a href="#utility">Utility</a></li><li><a href="#monadic-bindings">Monadic bindings</a></li><li><a href="#lists">Lists</a></li><li><a href="#pairs">Pairs</a></li></ul></nav></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> Stdlib.Option</code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code><code> = <span><span class="type-var">'a</span> option</span></code><code> = </code><table class="variant"><tr id="type-t.None" class="anchored"><td class="def constructor"><a href="#type-t.None" class="anchor"></a><code>| </code><code><span class="constructor">None</span></code></td></tr><tr id="type-t.Some" class="anchored"><td class="def constructor"><a href="#type-t.Some" class="anchor"></a><code>| </code><code><span class="constructor">Some</span> <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-none"><a href="#val-none" class="anchor"></a><code><span class="keyword">val</span> none : <span><span class="type-var">'a</span> option</span></code></dt><dt class="spec value" id="val-some"><a href="#val-some" class="anchor"></a><code><span class="keyword">val</span> some : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dt class="spec value" id="val-value"><a href="#val-value" class="anchor"></a><code><span class="keyword">val</span> value : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span>default:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span><span><span class="type-var">'a</span> option</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>none:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>some:<span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-is_none"><a href="#val-is_none" class="anchor"></a><code><span class="keyword">val</span> is_none : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_some"><a href="#val-is_some" class="anchor"></a><code><span class="keyword">val</span> is_some : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-to_result"><a href="#val-to_result" class="anchor"></a><code><span class="keyword">val</span> to_result : <span>none:<span class="type-var">'e</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> Stdlib.result</span></code></dt><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span class="keyword">val</span> to_seq : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Stdlib.Seq.t</span></code></dt></dl></details></div></div></div><section><header><h2 id="utility"><a href="#utility" class="anchor"></a>Utility</h2></header><dl><dt class="spec value" id="val-take_first"><a href="#val-take_first" class="anchor"></a><code><span class="keyword">val</span> take_first : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p>Take the value in the first argument if there is one, otherwise take the value in the second argument, otherwise <code>None</code></p></dd></dl><dl><dt class="spec value" id="val-(|||)"><a href="#val-(|||)" class="anchor"></a><code><span class="keyword">val</span> (|||) : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><a href="index.html#val-take_first"><code>take_first</code></a> as an operator:</p><p>Behave like boolean or but keep the value of the first option that gave true. This is associative but obviously not commutative.</p></dd></dl><dl><dt class="spec value" id="val-take_first_list"><a href="#val-take_first_list" class="anchor"></a><code><span class="keyword">val</span> take_first_list : <span><span><span class="type-var">'a</span> option</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p>Take the value of the first <code>Some</code> in the list. returns <code>None</code> if all the option were <code>None</code></p></dd></dl><dl><dt class="spec value" id="val-take_all"><a href="#val-take_all" class="anchor"></a><code><span class="keyword">val</span> take_all : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span></code></dt><dd><p>If both option have values, give <code>Some</code> of the pair, otherwise <code>None</code></p></dd></dl><dl><dt class="spec value" id="val-(&amp;&amp;&amp;)"><a href="#val-(&amp;&amp;&amp;)" class="anchor"></a><code><span class="keyword">val</span> (&amp;&amp;&amp;) : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span></code></dt><dd><p>Take_all as an operator:</p><p>Behave like boolean and but keep all the value of the options This is not associative because at type level (a * b) * c is not a * (b * c). Using monadic bindings is recommended for more that 2 operands.</p></dd></dl><dl><dt class="spec value" id="val-value_fail"><a href="#val-value_fail" class="anchor"></a><code><span class="keyword">val</span> value_fail : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, unit, string, <span class="type-var">'a</span>)</span> Stdlib.format4</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Expect the option to contain a value and fails (<code>Failure</code>) otherwise. The format string specify the content of the failure</p></dd></dl><dl><dt class="spec value" id="val-value_fun"><a href="#val-value_fun" class="anchor"></a><code><span class="keyword">val</span> value_fun : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span>default:<span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Like Stdlib.Option.value but the default is a called function, that can throw instead of giving a value</p></dd></dl><dl><dt class="spec value" id="val-of_bool"><a href="#val-of_bool" class="anchor"></a><code><span class="keyword">val</span> of_bool : <span>some:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p>Create an option from a bool, with the some value</p></dd></dl><dl><dt class="spec value" id="val-of_bool_fun"><a href="#val-of_bool_fun" class="anchor"></a><code><span class="keyword">val</span> of_bool_fun : <span>some:<span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p>Create an option from a bool, with the some value as computed by the some function</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all p o = fold ~none:true ~some:p</code></p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists p o = fold ~none:false ~some:p</code></p></dd></dl><dl><dt class="spec value" id="val-guard"><a href="#val-guard" class="anchor"></a><code><span class="keyword">val</span> guard : bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p>Return the second argument if the first is <code>true</code>, otherwise <code>None</code></p></dd></dl><dl><dt class="spec value" id="val-guardn"><a href="#val-guardn" class="anchor"></a><code><span class="keyword">val</span> guardn : bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p>Return the second argument if the first is <code>false</code>, otherwise <code>None</code></p></dd></dl></section><section><header><h2 id="monadic-bindings"><a href="#monadic-bindings" class="anchor"></a>Monadic bindings</h2></header><dl><dt class="spec value" id="val-let+"><a href="#val-let+" class="anchor"></a><code><span class="keyword">val</span> let+ : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dd><p>Applicative let.</p><p><code>let+ x = mx in e</code> is <code>Option.map (fun x -&gt; e) mx</code></p></dd></dl><dl><dt class="spec value" id="val-and+"><a href="#val-and+" class="anchor"></a><code><span class="keyword">val</span> and+ : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span></code></dt><dd><p>Applicative and.</p><p><code>let+ x = mx and+ y = my in e</code> give <code>Some e</code> if both <code>mx</code> and <code>my</code> were <code>Some</code>s.</p></dd></dl><dl><dt class="spec value" id="val-let+!"><a href="#val-let+!" class="anchor"></a><code><span class="keyword">val</span> let+! : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Iter applicative let.</p><p><code>let+! x = mx in e</code> runs <code>e</code> if <code>mx</code> contained a value i.e <code>Option.iter (fun x -&gt; e) mx</code></p></dd></dl><dl><dt class="spec value" id="val-let*"><a href="#val-let*" class="anchor"></a><code><span class="keyword">val</span> let* : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dd><p>Monadic let: <code>let* x = mx in e</code> is <code>Option.bind mx (fun x -&gt; e)</code></p></dd></dl><dl><dt class="spec value" id="val-and*"><a href="#val-and*" class="anchor"></a><code><span class="keyword">val</span> and* : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span></code></dt><dd><p>Monadic and: <code>let* x = mx and* y = my in e</code> is <code>let* x = mx in let* y = my in e</code></p></dd></dl></section><section><header><h2 id="lists"><a href="#lists" class="anchor"></a>Lists</h2></header><dl><dt class="spec value" id="val-lift"><a href="#val-lift" class="anchor"></a><code><span class="keyword">val</span> lift : <span><span><span class="type-var">'a</span> option</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> option</span></code></dt><dd><p>Commute the list and the option. If the list contains one <code>None</code> then the result is <code>None</code>. If you want to keep all the <code>Some</code> value, use <span class="xref-unresolved" title="unresolved reference to &quot;List.filter_map&quot;"><code>List</code>.filter_map</span>.</p><p>This can be condidered as a list-wide <a href="index.html#val-take_all"><code>take_all</code></a>. A list-wide <a href="index.html#val-take_first"><code>take_first</code></a> would be <span class="xref-unresolved" title="unresolved reference to &quot;List.find_map&quot;"><code>List</code>.find_map</span></p></dd></dl><dl><dt class="spec value" id="val-map_lift"><a href="#val-map_lift" class="anchor"></a><code><span class="keyword">val</span> map_lift : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> list</span> option</span></code></dt><dd><p>The same as a List.map and then a <a href="index.html#val-lift"><code>lift</code></a></p></dd></dl></section><section><header><h2 id="pairs"><a href="#pairs" class="anchor"></a>Pairs</h2></header><dl><dt class="spec value" id="val-lift_pair"><a href="#val-lift_pair" class="anchor"></a><code><span class="keyword">val</span> lift_pair : <span>(<span><span class="type-var">'a</span> option</span> * <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span></code></dt><dd><p>Lift a pair of options to an option of pair. It is the same as <a href="index.html#val-take_all"><code>take_all</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-unlift_pair"><a href="#val-unlift_pair" class="anchor"></a><code><span class="keyword">val</span> unlift_pair : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> * <span><span class="type-var">'b</span> option</span></code></dt><dd><p>Unlift an option of pair to a pair of options</p></dd></dl></section></div></body></html>