(** This module provide support for common command line option to be used across
    multiple subcomands *)

open Cmdliner

(*****************************************************************************)
(*****************************************************************************)
(*****************************************************************************)
(** {1 Option helper functions }

    Some Cmdliner helper functions.
*)

(** Return a unit [Term] that evaluates the input term and
    set the reference to the resulting value.

    Due to the nature of Cmdliner, this may be evaluated multiple times, so
    setting the reference to anything else is dangerous.
*)
let setter reference term =
  let set r t = r := t in
  Term.(const (set reference) $ term)

(** Add an unit term that need to be evaluated at the same time at the main term.

    The order of evaluation is unspecified, but the option will be evaluated
    before the resulting term is returned.
*)
let add_option opt term =
  let g a () = a in
  Term.(const g $ term $ opt)

(** Fold add_option on a list of option *)
let add_options olist term = List.fold_left (Fun.flip add_option) term olist

(** Replaces Term.const but allow a unit terms (like the one generated by {!setter}) to
    be evaluated before the function is called *)
let func_option opt func = add_option opt Term.(const func)

(** Same as {!func_option} but with a list of unit terms *)
let func_options olist func = add_options olist Term.(const func)

(*****************************************************************************)
(*****************************************************************************)
(*****************************************************************************)
(** {1 Exit codes } *)

let exits =
  let doc = "on external errors, (Parsing error, Typing error, ...)." in
  let doc2 = "on non-exception internal errors like assertion failed." in
  Term.exit_info ~doc 1 :: Term.exit_info ~doc:doc2 2 :: Term.default_exits

(*****************************************************************************)
(*****************************************************************************)
(*****************************************************************************)
(** {1 Config options } *)

let config =
  let doc =
    Printf.sprintf "Overrides the default location of the configuration file (%s)"
      ConfigPre.config_file
  in
  let env = Arg.env_var "READ_DWARF_CONFIG" ~doc in
  let doc = "Configuration file path" in
  Term.(
    const ConfigFile.ensure_loaded
    $ Arg.(
        value
        & opt non_dir_file ConfigPre.config_file
        & info ["c"; "config"] ~env ~docv:"CONFIG_TOML" ~doc))

let arch_val config archopt = Opt.value_fun archopt ~default:ConfigFile.get_arch_name

let arch_opt =
  let doc =
    "Override architecture to be analysed. If an ELF is provided this option is ignored and the \
     architecture of the ELF is used instead"
  in
  Arg.(value & opt (some ArchSig.Type.conv) None & info ["a"; "arch"] ~docv:"ARCH" ~doc)

let arch = Term.(const arch_val $ config $ arch_opt)

(*****************************************************************************)
(*****************************************************************************)
(*****************************************************************************)
(** {1 Isla options } *)

(** The isla_client path *)
let isla_client_ref = ref "isla-client"

let isla_client =
  let doc = "Overrides the default isla position (named isla-client)" in
  let env = Arg.env_var "ISLA_CLIENT" ~doc in
  let doc = "isla-client location" in
  setter isla_client_ref
    Arg.(value & opt string "isla-client" & info ["isla"] ~env ~docv:"ISLA_CLIENT_PATH" ~doc)

(*****************************************************************************)
(*****************************************************************************)
(*****************************************************************************)
(** {1 Z3 options } *)

(** The z3 command *)
let z3_ref = ref "z3"

(** The z3 option *)
let z3 =
  let doc = "Overrides the default z3 position" in
  let env = Arg.env_var "Z3_PATH" ~doc in
  let doc = "z3 location" in
  setter z3_ref Arg.(value & opt string "z3" & info ["z3"] ~env ~docv:"Z3_PATH" ~doc)

(*****************************************************************************)
(*****************************************************************************)
(*****************************************************************************)
(** {1 Logging options } *)

let quiet_ref = ref false

let quiet =
  let doc = "Remove all errors and warnings from the output" in
  Arg.(value & flag & info ["q"; "quiet"] ~doc)

let verbose =
  let doc = "Log more stuff. When set twice, output all debugging logs" in
  Arg.(value & flag_all & info ["v"; "verbose"] ~doc)

let infoopt : string list Term.t =
  let doc = "Set a precise OCaml module in info-logging mode" in
  Arg.(value & opt_all string [] & info ["info"] ~doc ~docv:"MODULE")

let debug =
  let doc = "Set a precise OCaml module in debug-logging mode" in
  Arg.(value & opt_all string [] & info ["debug"] ~doc ~docv:"MODULE")

let process_logs_opts quiet verbose info debug =
  if quiet then Logs.set_default_level Base;
  if quiet then quiet_ref := true;
  begin
    match verbose with
    | [] -> ()
    | [true] -> Logs.set_default_level Info
    | _ -> Logs.set_default_level Debug
  end;
  List.iter (fun name -> Logs.set_level name Info) info;
  List.iter (fun name -> Logs.set_level name Debug) debug

let logs_term = Term.(const process_logs_opts $ quiet $ verbose $ infoopt $ debug)

(*****************************************************************************)
(*****************************************************************************)
(*****************************************************************************)
(** {1 Common option list } *)

(** The list of common options. Almost all sub-commands should use this. *)
let comopts = [isla_client; z3; logs_term; config]
