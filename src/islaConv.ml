(* All the boring code is here, no interesting stuff going on,
   It was all generated by VIM macros. *)

let ty : Isla.ty -> 'a Ast.ty = function
  | Ty_Bool -> Ty_Bool
  | Ty_BitVec i -> Ty_BitVec i
  | Ty_Enum e -> Ty_Enum e

let unop : Isla.unop -> Ast.unop = function
  | Not -> Not
  | Bvnot -> Bvnot
  | Bvredand -> Bvredand
  | Bvredor -> Bvredor
  | Bvneg -> Bvneg
  | Extract (i, j) -> Extract (i, j)
  | ZeroExtend i -> ZeroExtend i
  | SignExtend i -> SignExtend i

let bvarith : Isla.bvarith -> Ast.bvarith = function
  | Bvnand -> Bvnand
  | Bvnor -> Bvnor
  | Bvxnor -> Bvxnor
  | Bvsub -> Bvsub
  | Bvudiv -> Bvudiv
  | Bvudivi -> Bvudivi
  | Bvsdiv -> Bvsdiv
  | Bvsdivi -> Bvsdivi
  | Bvurem -> Bvurem
  | Bvsrem -> Bvsrem
  | Bvsmod -> Bvsmod
  | Bvshl -> Bvshl
  | Bvlshr -> Bvlshr
  | Bvashr -> Bvashr

let bvcomp : Isla.bvcomp -> Ast.bvcomp = function
  | Bvult -> Bvult
  | Bvslt -> Bvslt
  | Bvule -> Bvule
  | Bvsle -> Bvsle
  | Bvuge -> Bvuge
  | Bvsge -> Bvsge
  | Bvugt -> Bvugt
  | Bvsgt -> Bvsgt

let bvmanyarith : Isla.bvmanyarith -> Ast.bvmanyarith = function
  | Bvand -> Bvand
  | Bvor -> Bvor
  | Bvxor -> Bvxor
  | Bvadd -> Bvadd
  | Bvmul -> Bvmul

let binop : Isla.binop -> 'm Ast.binop = function
  | Eq -> Eq
  | Neq -> Neq
  | Bvarith b -> Bvarith (bvarith b)
  | Bvcomp b -> Bvcomp (bvcomp b)

let manyop : Isla.manyop -> Ast.manyop = function
  | And -> And
  | Or -> Or
  | Bvmanyarith b -> Bvmanyarith (bvmanyarith b)
  | Concat -> Concat

let direct_exp_no_var (conv : 'a Isla.exp -> ('a, 'v, 'b, 'm) Ast.exp) :
    'a Isla.exp -> ('a, 'v, 'b, 'm) Ast.exp = function
  | Bits (b, a) -> Bits (BitVec.of_smt b, a)
  | Bool (b, a) -> Bool (b, a)
  | Enum (e, a) -> Enum (e, a)
  | Unop (u, e, a) -> Unop (unop u, conv e, a)
  | Binop (b, e, e', a) -> Binop (binop b, conv e, conv e', a)
  | Manyop (m, el, a) -> Manyop (manyop m, List.map conv el, a)
  | Ite (c, e, e', a) -> Ite (conv c, conv e, conv e', a)
  | Var (_, _) -> failwith "var in direct_exp_no_var"

let rec exp_var_conv (vconv : int -> 'v) : 'a Isla.exp -> ('a, 'v, 'b, 'm) Ast.exp = function
  | Var (i, a) -> Var (vconv i, a)
  | e -> direct_exp_no_var (exp_var_conv vconv) e

let exp e = exp_var_conv Fun.id e

(** Convert an expression from isla to Ast but using a var-to-exp conversion function *)
let rec exp_var_subst (vconv : int -> 'a -> ('a, 'v, 'b, 'm) Ast.exp) :
    'a Isla.exp -> ('a, 'v, 'b, 'm) Ast.exp = function
  | Var (i, a) -> vconv i a
  | e -> direct_exp_no_var (exp_var_subst vconv) e

let smt_var_conv (vconv : int -> 'v) : 'a Isla.smt -> ('a, 'v, 'b, 'm) Ast.smt = function
  | DeclareConst (i, t) -> DeclareConst (vconv i, ty t)
  | DefineConst (i, e) -> DefineConst (vconv i, exp_var_conv vconv e)
  | Assert e -> Assert (exp_var_conv vconv e)

let smt s = smt_var_conv Fun.id s
